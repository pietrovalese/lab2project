ARCHIVIO.C
Il file archivio.c genera 3 thread principali: capo_lettore, capo_scrittore e il gestore dei segnali. Vengono creati inoltre r thread lettori e w thread scrittori. Il thread capo_scrittore e il thread capo_lettore tengono conto rispettivamente del numero di scrittori e lettori che attraverso le funzioni aggiungi e conta operano sulla tabella hash creata all'inizio. La tabella hash è stata implementata come linked list che implica dei casting all struct della lista all'interno della funzione aggiungi e conta. E' stata creata un'ulteriore funzione per liberare il contenuto della tabella hash dopo aver terminato l'esecuzione. Per quanto riguarda la sincronizzazione ho utilizzato mutex, semafori e condition variable utilizzando uno schema che predilige i lettori. La struttura prod/cons è implementata infatti da una struct reader_writer_ che come campo ha un booleano (write_enable) che ci dice se uno scrittore sta scrivendo in questo momento e blocca sia scrittori che lettori. Dopo che uno scrittore ha terminato sarà lanciata una brodcast sulla condition variable in modo da svegliare tutti i lettori. La fun_caposcrittore permette di leggere dati dalla fifo coposc e, manetendo la sincronizzazione, di scriverli in un buffer condiviso con gli scrittori, che andranno ad aggiungereli (con la funzione aggiungi), alla tabella hash. La funzione fun_capolettore prende in input i dati della fifo capolet e li condivide in un buffer con i lettori che applicheranno la funzione conta su di essi. La funzione main si occupa di inizializzare e successivamente distruggere mutex, semafori e condition variable. Alla terminazione viene anche chiuso il file lettori.log. Il gestore dei segnali si occupa di ricevere e gestire i segnali in arrivo. I segnali gestiti sono 3: SIGINT, SIGUSR1 e SIGTERM.

SERVER.PY
Utilizzo logging.basicConfig per definire il file di log e il formato di scrittura dei vari accessi. Definisco 3 funzioni principali: la funzione main si occupa di controllare i parametri d'ingresso, in particolar modo il numero dei threads, apre le pipe capolet e caposc e lancia il programma archivio.c(eventualmente con valgrind se la flag -v è specificata)
Inizializzo il socket ed eseguo il binding dell'host e della porta e il server si mette in attesa di connessioni da parte dei client. La classe ThreadPoolExecutor si occupa di gestire i client in multithreading.
La funzione connessioni_fun prende come parametri la connessione, l'indirizzo del client e le due pipe. Dopo aver eseguito il controllo sul tipo di client si prepara a ricevere i dati dai client e scriverli nelle rispettive pipe.
La funzione recv_all è una funzione di sistema utilizzata per ricevere in maniera sicura e senza mancati invii, pacchetti di informazioni tra cliente e server

CLIENT1.C
Il client 1, che effettua una connessione di tipo A con il server, legge dal file fornito da riga di comando(utilizzando una getline) e dopo aver aperto il socket e aver stabilito la connessione col server invia riga per riga i dati al server. in modo particolare passo alla getline 3 parametri: un puntatore a carattere, che conterrà la linea letta dal file, la lunghezza della riga letta e il file da cui leggere. La getline è la condizione del ciclo while e ad ogni iterazione genero un nuovo socket

CLIENT2.PY
Il client 2, crea una connessione di tipo B per ogni file passato dalla riga di comando. Legge l'intero file e lo invia interamente con una sendall al server. Prima di terminare riceve il numero di sequenze per ogni socket creato


